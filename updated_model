import pyomo.environ as pyo
import pandas as pd
import classes
import functions
import inspect 

# ---------------------------------------------------------------------------------------------------------------------
# region reading data

path_input = './input/'
path_output = './output/'
name_file = 'df_input.xlsx'

df_input_series = pd.read_excel(path_input +name_file, sheet_name= 'series')
df_input_other = pd.read_excel(path_input +name_file, sheet_name= 'other')
df_elements = pd.read_excel(path_input + name_file, sheet_name = 'elements')
[df_matrix, df_aux] = functions.matrix_creator(df_elements)


#endregion
# ---------------------------------------------------------------------------------------------------------------------
# region create classes

class bat:
    def charge_limit(model,t,m):
        return model.P_to_bat[t,m] <= model.E_bat_max[m] * model.K_ch[t,m]
    
    def discharge_limit(model,t,m):
        return model.P_from_bat[t,m] <= model.E_bat_max[m] * model.K_dis[t,m]
    
    def keys_rule(model,t,m):
        return model.K_ch[t,m] + model.K_dis[t,m] <= 1

battery_rule = lambda model, t: model.SOC[t] == model.starting_SOC if t == 1 else model.SOC[t] == model.SOC[t-1] + (model.P_to_bat[t-1] - model.P_from_bat[t-1]) * model.time_step / model.E_bat_max
setattr(bat, "battery_rule", battery_rule)

class pv:
    def solar_rule(model,t,n):
        return model.P_from_pv[t,n] == model.P_solar[t] * model.pv_eff[n]

# input("Press Enter to continue...")

#endregion
# ---------------------------------------------------------------------------------------------------------------------
# region abstract creating model

#model
model = pyo.AbstractModel()

#sets
model.HOURS = pyo.Set()

#endregion
# ---------------------------------------------------------------------------------------------------------------------
# region abstract creating model

#parameter scalar
model.time_step = pyo.Param()
model.pv_eff = pyo.Param()

model.starting_SOC = pyo.Param()
model.E_bat_max = pyo.Param()

#parameters series
model.P_solar = pyo.Param(model.HOURS) #time series with solar energy
model.P_to_demand = pyo.Param(model.HOURS) #time series with solar energy
model.costBuy = pyo.Param(model.HOURS) #time series with costs of buying energy
model.costSell = pyo.Param(model.HOURS) #time series with price of energy being sold to grid

#endregion
# ---------------------------------------------------------------------------------------------------------------------
# region creating variables

model.P_to_net1 = pyo.Var(model.HOURS, within = pyo.NonNegativeReals)
model.P_from_net1 = pyo.Var(model.HOURS, within = pyo.NonNegativeReals)
model.P_net_demand1 = pyo.Var(model.HOURS, within = pyo.NonNegativeReals)
model.P_net1_bat1 = pyo.Var(model.HOURS, within = pyo.NonNegativeReals)

model.P_from_pv1 = pyo.Var(model.HOURS, within = pyo.NonNegativeReals)
model.P_pv1_net1 = pyo.Var(model.HOURS, within = pyo.NonNegativeReals)
model.P_pv1_bat1 = pyo.Var(model.HOURS, within = pyo.NonNegativeReals)
model.P_pv1_demand1 = pyo.Var(model.HOURS, within = pyo.NonNegativeReals)

model.SOC = pyo.Var(model.HOURS, within = pyo.NonNegativeReals, bounds=(0, 1))
model.P_to_bat1 = pyo.Var(model.HOURS, within = pyo.NonNegativeReals)
model.P_from_bat1 = pyo.Var(model.HOURS, within = pyo.NonNegativeReals)
model.P_bat1_net1 = pyo.Var(model.HOURS, within = pyo.NonNegativeReals)
model.P_bat1_demand1 = pyo.Var(model.HOURS, within = pyo.NonNegativeReals)

model.K_ch = pyo.Var(model.HOURS, domain = pyo.Binary)
model.K_dis = pyo.Var(model.HOURS, domain = pyo.Binary)

model.E_sell = pyo.Var(model.HOURS, within = pyo.NonNegativeReals)
model.E_buy = pyo.Var(model.HOURS, within = pyo.NonNegativeReals)

#endregion
# ---------------------------------------------------------------------------------------------------------------------
# region creating contraints from classes

constraint_num = 1
for i in df_aux.index:
    if df_aux['type'].iloc[i] in ['pv','bat']:
        element = df_aux['elements'].iloc[i]
        class_type = df_aux['type'].iloc[i]

        class CustomMetaclass(type(class_type)):
            pass

        print(element)
        print(class_type)
        new_class = CustomMetaclass(element, (class_type,), {})
        globals()[element] = new_class

        myObj = globals()[element]
        
        for j in dir(myObj):
            if not j.startswith('__'):
                original_method = getattr(myObj, j)
                source_code = inspect.getsource(original_method)
                modified_source_code = source_code.replace(df_aux['type'].iloc[i],df_aux['elements'].iloc[i])
                print(modified_source_code)
                compiled_code = compile(modified_source_code, "<string>", "exec")
                namespace = {}
                exec(compiled_code, namespace)
                modified_method = namespace[j]
                setattr(myObj, j, modified_method)
                model.add_component('Constraint_'+constraint_num, pyo.Constraint(model.HOURS, rule = myObj.j))
                constraint_num += 1  



# #endregion
# # ---------------------------------------------------------------------------------------------------------------------
# # region creating connection constraints 


# # endregion
# # ---------------------------------------------------------------------------------------------------------------------
# # region other constraints

# #demand rule
# def demand_rule(model,t):
#     return model.P_to_demand1[t] == model.P_pv1_demand1[t] + model.P_net1_demand1[t] + model.P_bat1_demand1[t]
# model.demandRule = pyo.Constraint(model.HOURS,rule = demand_rule)

# #net_rule
# def net_rule(model,t):
#      return model.P_from_net[t] == model.P_to_demand1[t] + model.P_net1_bat1[t]
# model.netRule = pyo.Constraint(model.HOURS, rule = net_rule)

# def pv_rule(model,t):
#     return model.P_from_pv1[t] == model.P_pv1_bat1[t] + model.P_pv1_net[t] + model.P_pv1_demand1[t]
# model.pvRule = pyo.Constraint(model.HOURS, rule = pv_rule)

# def charge_rule(model,t):
#      return model.P_to_bat1[t] == model.P_pv1_bat1[t] + model.P_net1_bat1[t]
# model.chargeRule = pyo.Constraint(model.HOURS,rule = charge_rule)

# def discharge_rule(model,t):
#      return model.P_from_bat1[t] == model.P_bat1_net1[t] + model.P_bat1_demand1[t]
# model.dischargeRule = pyo.Constraint(model.HOURS,rule = discharge_rule)

# #related to objective rule
# def sell_rule(model,t):
#      return model.P_to_net1[t] == model.P_pv1_net1[t] + model.P_bat1_net1[t]
# model.sellRule = pyo.Constraint(model.HOURS,rule = sell_rule)

# def sell_energy(model,t):
#     return model.E_sell[t] == model.P_to_net1[t] * model.time_step
# model.sellEnergy = pyo.Constraint(model.HOURS, rule = sell_energy)

# def buy_energy(model,t):
#      return model.E_buy[t] == model.P_from_net1[t] * model.time_step  
# model.buyEnergy = pyo.Constraint(model.HOURS, rule = buy_energy)

# # endregion
# # ---------------------------------------------------------------------------------------------------------------------
# # region objective

# #objective function
# def objective_rule(model,t):
#      return sum(model.E_buy[t] * model.costBuy[t] - model.E_sell[t] * model.costSell[t] for t in model.HOURS)
# model.objectiveRule = pyo.Objective(rule = objective_rule,sense= pyo.minimize)

# # endregion
# # ---------------------------------------------------------------------------------------------------------------------
# # region reading data

# #reading data
# data = pyo.DataPortal()
# data['HOURS'] = df_input_series['HOURS'].tolist()
# data['P_solar'] = df_input_series.set_index('HOURS')['P_solar'].to_dict()
# data['P_to_demand1'] = df_input_series.set_index('HOURS')['P_to_demand1'].to_dict()
# data['costBuy'] = df_input_series.set_index('HOURS')['costBuy'].to_dict()
# data['costSell'] = df_input_series.set_index('HOURS')['costSell'].to_dict()

# data['pv_eff'] = {None:df_input_other.loc[df_input_other['Parameter'] == 'pv_eff', 'Value'].values[0]}
# data['E_bat_max'] = {None:df_input_other.loc[df_input_other['Parameter'] == 'E_bat_max', 'Value'].values[0]}
# data['starting_SOC'] = {None:df_input_other.loc[df_input_other['Parameter'] == 'starting_SOC', 'Value'].values[0]}
# data['time_step'] = {None:df_input_other.loc[df_input_other['Parameter'] == 'time_step', 'Value'].values[0]}


# # endregion
# # ---------------------------------------------------------------------------------------------------------------------
# # region starting model

# #generating instance
# instance = model.create_instance(data)

# #solving the model
# optimizer = pyo.SolverFactory('cplex')
# results = optimizer.solve(instance)

# # # Displaying the results
# # instance.pprint()
# instance.display()

# #endregion
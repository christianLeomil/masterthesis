import pyomo.environ as pyo
import pandas as pd
import classes
import functions
import inspect
import textwrap
import warnings

warnings.filterwarnings("ignore", '.*')

# ---------------------------------------------------------------------------------------------------------------------
# region reading data

path_input = './input/'
path_output = './output/'
name_file = 'df_input.xlsx'

df_input_series = pd.read_excel(path_input +name_file, sheet_name= 'series')
df_input_other = pd.read_excel(path_input +name_file, sheet_name= 'other')
df_elements = pd.read_excel(path_input + name_file, sheet_name = 'elements')
[df_matrix, df_aux] = functions.matrix_creator(df_elements)
df_aux.to_excel(path_output + 'df_aux.xlsx',index = False)
df_matrix.to_excel(path_output + 'df_matrix.xlsx') 

input("Press Enter to continue...")

df_conect = pd.read_excel(path_input + name_file, sheet_name = 'conect',index_col = 0)
df_conect.index.name = None
df_conect.to_excel(path_output + 'df_conect.xlsx')
[df_conect, list_expressions, list_con_variables] = functions.connection_creator(df_conect)

# print('---------------------------list of conection expressions------------------------------')
# print(list_expressions)
# print('\n')
# print('----------------------------list of conection variables-------------------------------')
# print(list_con_variables)
# print('\n')

#endregion
# ---------------------------------------------------------------------------------------------------------------------
# region abstract creating model

#model
model = pyo.AbstractModel()

#sets
model.HOURS = pyo.Set()

#endregion
# ---------------------------------------------------------------------------------------------------------------------
# region parameters related to sets

model.time_step = pyo.Param()
model.P_solar = pyo.Param(model.HOURS) #time series with solar energy
model.P_to_demand1 = pyo.Param(model.HOURS) #time series with solar energy
model.costBuy = pyo.Param(model.HOURS) #time series with costs of buying energy
model.costSell = pyo.Param(model.HOURS) #time series with price of energy being sold to grid

#endregion
# ---------------------------------------------------------------------------------------------------------------------
# region dynamically creating parameters and variables from classes

# creating variables from classes
for i in df_aux.index:
    element = df_aux['element'].iloc[i]
    class_type = df_aux['type'].iloc[i]
    if df_aux['type'].iloc[i] in ['pv','bat']: 
        myObj = getattr(classes,class_type)
        myObj = myObj()
        list_classes_variables = [s.replace(class_type, element) for s in myObj.list_var]
        for j,m in enumerate(list_classes_variables):
            specifications = myObj.list_text_var[j]
            text = 'model.HOURS,' + specifications
          #   print(m)
          #   print(specifications)
            exec(f"model.add_component('{m}',pyo.Var({text}))")

# print('----------------------------------------------------------')

# creating parameters from classes
for i in df_aux.index:
    element = df_aux['element'].iloc[i]
    class_type = df_aux['type'].iloc[i]
    if df_aux['type'].iloc[i] in ['pv','bat']:
        myObj = getattr(classes,class_type)
        myObj = myObj()
        list_classes_parameters = [s.replace(class_type, element) for s in myObj.list_param]
        for j,m in enumerate(list_classes_parameters):
            specifications = myObj.list_text_param[j]
            text = specifications
          #   print(m)
          #   print(specifications)
            exec(f"model.add_component('{m}',pyo.Param({text}))")

#endregion
# ---------------------------------------------------------------------------------------------------------------------
# region dynamically creating variables from connections

for i in list_con_variables:
    if i in ['P_to_demand1']:
        pass
    else:
        print(i)
        text = 'model.HOURS, within = pyo.NonNegativeReals'
        exec(f"model.add_component('{i}',pyo.Var({text}))")

#endregion
# ---------------------------------------------------------------------------------------------------------------------
# region creating variables

model.E_sell = pyo.Var(model.HOURS, within = pyo.NonNegativeReals)
model.E_buy = pyo.Var(model.HOURS, within = pyo.NonNegativeReals)

#endregion
# ---------------------------------------------------------------------------------------------------------------------
# region creating contraints from classes

class MyClass:
     pass

method_num = 0
for i in df_aux.index:
    element = df_aux['element'].iloc[i]
    class_type = df_aux['type'].iloc[i]
    if class_type in ['bat','pv']:
        myObj = getattr(classes, class_type)

        for j in dir(myObj):
            if j.startswith('__'):
                pass
            else:
                method_num += 1
                print('method'+str(method_num))
                # Get the original method
                original_method = getattr(myObj,j)
                print(original_method)
                # Get the source code of the method
                source_code = inspect.getsource(original_method)
                # taking away indentation, correct reading of function
                source_code = textwrap.dedent(source_code)
                # Replace the parameter name
                modified_source_code = source_code.replace(class_type, element)
                print(modified_source_code)
                # Compile the modified source code
                compiled_code = compile(modified_source_code, "<string>", "exec")
                # Create a namespace dictionary for execution
                namespace = {}
                # Execute the compiled code in the namespace
                exec(compiled_code, namespace)
                # Get the modified method from the namespace
                modified_method = namespace[j] 
                # Set the modified method as the new method_1
                setattr(MyClass, 'method'+str(method_num), modified_method)

constraint_num = 1
for i in dir(MyClass):
      if i.startswith('__'):
            pass
      else:
           method = getattr(MyClass,i)
           model.add_component('Constraint_class_'+ str(constraint_num), pyo.Constraint(model.HOURS, rule = method))
           constraint_num += 1

#endregion
# ---------------------------------------------------------------------------------------------------------------------
# region creating connection constraints 

class myClass:
    pass

constraint_number = 1
for i in list_expressions:
    def dynamic_method(model,t,expr):
        return eval(expr, globals(), locals())
    method_name = 'Constraint_con_' + str(constraint_number)

    def method_wrapper(self, model,t,expr=i):
        return dynamic_method(model,t,expr)
    setattr(myClass, method_name, method_wrapper)
    my_obj = myClass()
    setattr(model, 'Constraint_con_' + str(constraint_number), pyo.Constraint(model.HOURS,rule=getattr(my_obj, method_name)))
    constraint_number = constraint_number + 1

# endregion
# ---------------------------------------------------------------------------------------------------------------------
# region other constraints

def sell_energy(model,t):
    return model.E_sell[t] == model.P_to_net1[t] * model.time_step
model.sellEnergy = pyo.Constraint(model.HOURS, rule = sell_energy)

def buy_energy(model,t):
     return model.E_buy[t] == model.P_from_net1[t] * model.time_step  
model.buyEnergy = pyo.Constraint(model.HOURS, rule = buy_energy)

# endregion
# ---------------------------------------------------------------------------------------------------------------------
# region objective

#objective function
def objective_rule(model,t):
     return sum(model.E_buy[t] * model.costBuy[t] - model.E_sell[t] * model.costSell[t] for t in model.HOURS)
model.objectiveRule = pyo.Objective(rule = objective_rule,sense= pyo.minimize)

# endregion
# ---------------------------------------------------------------------------------------------------------------------
# region reading data

#reading data
data = pyo.DataPortal()
data['HOURS'] = df_input_series['HOURS'].tolist()
data['P_solar'] = df_input_series.set_index('HOURS')['P_solar'].to_dict()
data['P_to_demand1'] = df_input_series.set_index('HOURS')['P_to_demand1'].to_dict()
data['costBuy'] = df_input_series.set_index('HOURS')['costBuy'].to_dict()
data['costSell'] = df_input_series.set_index('HOURS')['costSell'].to_dict()

data['pv1_eff'] = {None:df_input_other.loc[df_input_other['Parameter'] == 'pv1_eff', 'Value'].values[0]}
data['pv1_area'] = {None:df_input_other.loc[df_input_other['Parameter'] == 'pv1_area', 'Value'].values[0]}

data['pv2_eff'] = {None:df_input_other.loc[df_input_other['Parameter'] == 'pv2_eff', 'Value'].values[0]}
data['pv2_area'] = {None:df_input_other.loc[df_input_other['Parameter'] == 'pv2_area', 'Value'].values[0]}

data['bat1_E_max'] = {None:df_input_other.loc[df_input_other['Parameter'] == 'bat1_E_max', 'Value'].values[0]}
data['bat1_starting_SOC'] = {None:df_input_other.loc[df_input_other['Parameter'] == 'bat1_starting_SOC', 'Value'].values[0]}
data['bat1_c_rate_ch'] = {None:df_input_other.loc[df_input_other['Parameter'] == 'bat1_c_rate_ch', 'Value'].values[0]}
data['bat1_c_rate_dis'] = {None:df_input_other.loc[df_input_other['Parameter'] == 'bat1_c_rate_dis', 'Value'].values[0]}
data['bat1_ch_eff'] = {None:df_input_other.loc[df_input_other['Parameter'] == 'bat1_ch_eff', 'Value'].values[0]}
data['bat1_dis_eff'] = {None:df_input_other.loc[df_input_other['Parameter'] == 'bat1_dis_eff', 'Value'].values[0]}

data['bat2_E_max'] = {None:df_input_other.loc[df_input_other['Parameter'] == 'bat2_E_max', 'Value'].values[0]}
data['bat2_starting_SOC'] = {None:df_input_other.loc[df_input_other['Parameter'] == 'bat2_starting_SOC', 'Value'].values[0]}
data['bat2_c_rate_ch'] = {None:df_input_other.loc[df_input_other['Parameter'] == 'bat2_c_rate_ch', 'Value'].values[0]}
data['bat2_c_rate_dis'] = {None:df_input_other.loc[df_input_other['Parameter'] == 'bat2_c_rate_dis', 'Value'].values[0]}
data['bat2_ch_eff'] = {None:df_input_other.loc[df_input_other['Parameter'] == 'bat2_ch_eff', 'Value'].values[0]}
data['bat2_dis_eff'] = {None:df_input_other.loc[df_input_other['Parameter'] == 'bat2_dis_eff', 'Value'].values[0]}

data['time_step'] = {None:df_input_other.loc[df_input_other['Parameter'] == 'time_step', 'Value'].values[0]}

# endregion
# ---------------------------------------------------------------------------------------------------------------------
# region starting model

#generating instance
instance = model.create_instance(data)

#printing constriants to check (uncomment to see all contraints)
# print("Constraint Expressions:")
# for constraint in instance.component_objects(pyo.Constraint):
#     for index in constraint:
#         print(f"{constraint}[{index}]: {constraint[index].body}")

#solving the model
optimizer = pyo.SolverFactory('cplex')
results = optimizer.solve(instance)

# # Displaying the results
# instance.pprint()
instance.display()

# endregion
# ---------------------------------------------------------------------------------------------------------------------
# region exporting results

variable_names =[]
for var_component in instance.component_objects(pyo.Var):
    for var in var_component.values():
        variable_names.append(var.name)

for i in range(len(variable_names)):
    # Find the index of '['
    index = variable_names[i].find('[') 
    # Remove the text after '[' including '['
    variable_names[i] = variable_names[i][:index]

variable_names = list(set(variable_names))

# Create an empty DataFrame to store the variable values
df_variable_values = pd.DataFrame(columns=['TimeStep'] + variable_names)

# Iterate over the time steps and extract the variable values
for t in instance.HOURS:
    row = {'TimeStep': t}
    for var_name in variable_names:
        var_value = getattr(instance, var_name)
        row[var_name] = pyo.value(var_value[t])
    df_variable_values = df_variable_values.append(row, ignore_index=True)

# Display the DataFrame with the variable values
df_variable_values.to_excel(path_output + 'variable_values.xlsx',index = False)

#endregion